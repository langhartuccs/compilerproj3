<*=============driver code =============*>
<input syntax="Cfront.code" parse=CODE.StmtList from="" to=ast/>
	
<* use the print out to figure out the AST definitions in POET/lib/Cfront.code; 
	  comment it out before your final submission*>
<* <eval PRINT(ast); /> *>
	
<* If you plan to work on 3-adress code generation, please check out 
	  code in POET/examples/compiler_5.pt; 
	   If you plan to work on control flow graph construction, please check
	  out code in POET/examples/compiler_6.pt. *>
	
	
<*============== control flow graph IR and management =====*>
<define cfg_nodes NULL/> <* resulting CFG nodes generated *>
<define cfg_edges NULL/> <* resulting CFG edges generated *>
<define label_index 0/> <* index of new basic blocks created *>

<* a function that returns a new label *>
<xform new_label >  
    output = GLOBAL.label_index; 
    GLOBAL.label_index=GLOBAL.label_index+1; 
    output; 
</xform>

<* basic block IR date structure *>
<code BasicBlock pars=(label, stmts)>
    B@label@[@CODE.print_list#(stmts,";")@]
</code>

<* CFG edge IR date structure *>
<code Flow pars=(from, to)>
    B@from@->B@to@
</code>

<code CFG pars=(nodes, edges)>

digraph CFG
{
@CODE.print_list#(nodes,"\n")@

@CODE.print_list#(edges,"\n")@
}
</code>
	
<* print out the content backward *>
<code print_list pars=(content,sep)>
@((TAIL(content) : "")? HEAD(content) :
(print_list#(TAIL(content),sep) sep HEAD(content)))@
</code>

<* a function for generate a new basic block *>
<xform new_basicblock pars=(stmts)>
	label = XFORM.new_label();
	GLOBAL.cfg_nodes = BasicBlock#(label, stmts) :: GLOBAL.cfg_nodes;
	label
</xform>

<* a function for generate a new cfg edge *>
<xform new_flow pars=(from, to)>
	GLOBAL.cfg_edges = Flow#(from, to) :: GLOBAL.cfg_edges;
</xform>


<*=============== translation schemes for control flow graph contruction =========*>
<* implement translation scheme for all productions of non-terminal Goal *>
<xform BuildCFG__Goal pars=(input, begin)>
	switch (input) {
        case CODE.Nest : XFORM.BuildCFG__Nest(input, begin);
        case CODE.SingleStmt : XFORM.BuildCFG__SingleStmt(input, begin);
    	case (head tail) : <* a list of multiple statements *>
           PRINT("LIST");
    	   next=BuildCFG__Goal(head,begin);
    	   if (tail != "") { BuildCFG__Goal(tail,next) }
    	   else { next }
    	default : XFORM.BuildCFG__Any(input, begin); <*input :: begin*>
	}
</xform>

<* implement translation scheme for all productions of non-terminal While *>
<xform BuildCFG__While pars=(while_ast, block_ast, begin)>
    PRINT("WHILE");
	While#(condition) = while_ast;
    SingleStmt#(body) = block_ast;
    b_test = new_basicblock(condition);
	body_label= GLOBAL.label_index; <* label for the first basic block of body *>
	body = XFORM.BuildCFG__Goal(begin,""); <* label of the last basic block from loop body *>
	exit_label = new_label(); <* exit label for the loop*>
    <* new generate cfg edges *>
	new_flow(b_test, body_label);
	new_flow(b_test, exit_label);
	new_flow(body_label, b_test);
	"" <* the exit block is currently empty*>
</xform>

<xform BuildCFG__If pars=(if_ast, block_ast, begin)>
    PRINT("IF");
    If#(condition) = if_ast;
    SingleStmt#(body) = block_ast;
    XFORM.BuildCFG__Goal(ctrl, begin);
    ""
</xform>

<xform BuildCFG__Nest pars=(input,begin)>
    PRINT("NEST");
    Nest#(ctrl, body) = input;
    switch(ctrl){
        case CODE.While : 
            RETURN XFORM.BuildCFG__While(ctrl, body, begin);
        case CODE.If : 
            RETURN XFORM.BuildCFG__If(ctrl, body, begin);
        default :
            RETURN ""
    }
</xform>

<xform BuildCFG__Any pars=(input,begin)>
    PRINT("ANY");
    new_basicblock("ANY");
    ""
</xform>


<*===================== driver code ===================*>
<* start evaluation *>
<eval last = BuildCFG__Goal(ast, "");
	new_basicblock(""); <* generate the last basic block *>
	/>

<* write the 3-address ir to the given output file*>
<output from=(CFG#(cfg_nodes, cfg_edges)) syntax="Cfront.code" />